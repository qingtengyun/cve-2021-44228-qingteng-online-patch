import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;

import javax.net.SocketFactory;
import javax.net.ServerSocketFactory;
import javax.net.ssl.SSLSocketFactory;

import com.sun.net.httpserver.HttpServer;
import com.unboundid.ldap.listener.InMemoryDirectoryServer;
import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;
import com.unboundid.ldap.listener.InMemoryListenerConfig;
import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;
import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;
import com.unboundid.ldap.sdk.Entry;
import com.unboundid.ldap.sdk.LDAPException;
import com.unboundid.ldap.sdk.LDAPResult;
import com.unboundid.ldap.sdk.ResultCode;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;



public class LDAPServer {

	private static final String LDAP_BASE = "dc=qingteng,dc=cn";

	static Logger logger = LogManager.getLogger(LDAPServer.class);

	public static void main ( String[] args ) {
		int port = 80;

		final String LOG4J_HOTFIX_DOWNLOAD_PATH = System.getenv("LOG4J_HOTFIX_DOWNLOAD_PATH") == null ?
			"https://cve-2021-44228.qingteng.cn/patch/class/" : System.getenv("LOG4J_HOTFIX_DOWNLOAD_PATH");

		try {
			InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);
			config.setListenerConfigs(new InMemoryListenerConfig(
					"listen",
					InetAddress.getByName("0.0.0.0"),
					port,
					ServerSocketFactory.getDefault(),
					SocketFactory.getDefault(),
					(SSLSocketFactory) SSLSocketFactory.getDefault()));

			config.addInMemoryOperationInterceptor(new OperationInterceptor(LOG4J_HOTFIX_DOWNLOAD_PATH));
			InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);
			logger.info("LPAPServer listening on 0.0.0.0:" + port);
			ds.startListening();
		}
		catch ( Exception e ) {
			e.printStackTrace();
		}
		startHTTPServer();
	}

	public static byte[] hexStringToByteArray(String s) {
		int len = s.length();
		byte[] data = new byte[len / 2];
		for (int i = 0; i < len; i += 2) {
			data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
					+ Character.digit(s.charAt(i+1), 16));
		}
		return data;
	}

	private static void startHTTPServer(){
		try {
			HttpServer httpServer = HttpServer.create(new InetSocketAddress(8080), 0);
			httpServer.createContext("/", httpExchange -> new Thread(() -> {
				try {
					String requestURI = httpExchange.getRequestURI().toString();
					if(requestURI.endsWith("Hotfix.class")){
						String[] arr = requestURI.split("/");
						if(arr.length > 2) {
							String uuid = arr[arr.length - 2];
							if(uuid.length() < 51) {
								byte[] chunk2 = {(byte) (0x24 + uuid.length())};
								byte[] chunk4 = uuid.getBytes();
								byte[] respContents = concat(c2b(HotfixGenerator.chunk1), chunk2,
										c2b(HotfixGenerator.chunk3), chunk4,
										c2b(HotfixGenerator.chunk5));
								httpExchange.getResponseHeaders().add("Content-Type", "application/octet-stream");
								httpExchange.sendResponseHeaders(200, respContents.length);
								httpExchange.getResponseBody().write(respContents);
							}
						}
					}

				}catch (IOException e)
				{
					logger.error(e);
				}
				httpExchange.close();
			}).start());
			httpServer.start();
			logger.info("HTTPServer listening on 0.0.0.0:8080");
		}catch (IOException e){

		}
	}


	public static byte[] c2b(char[] array) {
		byte[] result = new byte[array.length];
		for(int i = 0; i < array.length; i++) {
			result[i] = (byte) array[i];
		}
		return result;
	}

	public static byte[] concat(byte[]...arrays)
	{
		int totalLength = 0;
		for (int i = 0; i < arrays.length; i++)
		{
			totalLength += arrays[i].length;
		}

		byte[] result = new byte[totalLength];

		int currentIndex = 0;
		for (int i = 0; i < arrays.length; i++)
		{
			System.arraycopy(arrays[i], 0, result, currentIndex, arrays[i].length);
			currentIndex += arrays[i].length;
		}
		return result;
	}

	private static class OperationInterceptor extends InMemoryOperationInterceptor {
		private String codebase;

		public OperationInterceptor ( String cb ) {
			this.codebase = cb;
		}

		@Override
		public void processSearchResult (InMemoryInterceptedSearchResult result) {
			String base = result.getRequest().getBaseDN();
			logger.info("processSearchResult");
			Entry e = new Entry(base);
			try {
				sendResult(result, base, e);
			}
			catch ( Exception e1 ) {
				e1.printStackTrace();
			}

		}

		protected void sendResult (InMemoryInterceptedSearchResult result, String base, Entry e){
			e.addAttribute("javaClassName", "Hotfix");
			e.addAttribute("objectClass", "javaNamingReference");
			e.addAttribute("javaFactory", "Hotfix");
			e.addAttribute("javaCodeBase", codebase + base + "/");

			try {
				result.sendSearchEntry(e);
				result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
			}catch (LDAPException err){
				logger.error(err);
			}
		}

	}
}